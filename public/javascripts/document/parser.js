// Generated by CoffeeScript 1.6.3
(function() {
  var DocumentSourceParser, Stream;

  DocumentSourceParser = (function() {
    function DocumentSourceParser(schema) {
      this.schema = schema;
    }

    DocumentSourceParser.prototype.theme_re = /^#(\d+)/;

    DocumentSourceParser.prototype.isTheme = function() {
      var $;
      if ($ = this.stream.match(this.theme_re)) {
        return {
          type: 'theme',
          type: $[0]
        };
      }
    };

    DocumentSourceParser.prototype.genre_re = /^@(\d+)/;

    DocumentSourceParser.prototype.isGenre = function() {
      var $;
      if ($ = this.stream.match(this.genre_re)) {
        return {
          type: 'genre',
          type: $[0]
        };
      }
    };

    DocumentSourceParser.prototype.ques_re = /^%(.+?)%/;

    DocumentSourceParser.prototype.isQues = function() {
      var $;
      if ($ = this.stream.match(this.ques_re)) {
        return {
          type: 'ques',
          text: $[0]
        };
      }
    };

    DocumentSourceParser.prototype.lex_re = /^([а-я,ё,\-,\+]+?)\s*\{(.*?)\}/i;

    DocumentSourceParser.prototype.isLex = function() {
      var $;
      if ($ = this.stream.match(this.lex_re)) {
        this.__lp = {
          type: 'lex',
          name: $[0]
        };
        this.parseDescription($[1]);
        return this.__lp;
      }
    };

    DocumentSourceParser.prototype.description_splitter = '|';

    DocumentSourceParser.prototype.morph_splitter = /\=|\,/;

    DocumentSourceParser.prototype.first_lit_re = /^(.+)\((.+)\)/;

    DocumentSourceParser.prototype.parseDescription = function(str) {
      var description, description_strs, descriptions, dstr, k, propertie, propertie_str, propertie_strs, v, _i, _j, _len, _len1, _ref, _results;
      description_strs = str.split(this.description_splitter);
      descriptions = [];
      if (description_strs.length > 1) {
        this.addWarning('Multi-values lexem');
        this.__lp.type = 'lex-set';
        this.__lp.descriptions = [];
      }
      for (_i = 0, _len = description_strs.length; _i < _len; _i++) {
        dstr = description_strs[_i];
        description = {};
        propertie_strs = dstr.split(this.morph_splitter);
        for (_j = 0, _len1 = propertie_strs.length; _j < _len1; _j++) {
          propertie_str = propertie_strs[_j];
          if (propertie_str == null) {
            this.addWarning('Empty propertie');
            continue;
          }
          if (this.first_lit_re.test(propertie_str)) {
            description.first = RegExp.$1;
            description.lit = RegExp.$2;
          } else {
            propertie = this.encodePropertie(propertie_str);
            if (propertie != null) {
              description[propertie.key] = propertie.val;
            }
          }
        }
        this.checkDescription(description);
        descriptions.push(description);
      }
      if (this.__lp.type === 'lex-set') {
        return this.__lp.descriptions = descriptions;
      } else {
        _ref = descriptions[0];
        _results = [];
        for (k in _ref) {
          v = _ref[k];
          _results.push(this.__lp[k] = v);
        }
        return _results;
      }
    };

    DocumentSourceParser.prototype.encodePropertie = function(str) {
      var r;
      if (str === 'од') {
        return this.addError("Invalid property " + str);
      } else {
        r = {};
        r[str] = true;
        return r;
      }
    };

    DocumentSourceParser.prototype.checkDescription = function(description) {};

    DocumentSourceParser.prototype.addMessage = function(type, message) {
      this.log.messages.push({
        line: this.stream.line,
        pos: this.stream.pos,
        text: message,
        type: type
      });
      return this.log[type + 's']++;
    };

    DocumentSourceParser.prototype.addError = function(message) {
      return this.addMessage('error', message);
    };

    DocumentSourceParser.prototype.addWarning = function(message) {
      return this.addMessage('warning', message);
    };

    DocumentSourceParser.prototype.parse = function(src, document) {
      var content, item, state;
      this.log = {
        messages: [],
        errors: 0,
        warnings: 0
      };
      state = {
        genre: null,
        theme: null,
        plain: ''
      };
      this.stream = new Stream(src);
      content = [];
      while (!this.stream.empty()) {
        item = this.isLex() || this.isQues() || this.isGenre() || this.isTheme();
        if (item) {
          if (state.plain.length) {
            content.push(state.plain);
            state.plain = '';
          }
          content.push(item);
        } else {
          state.plain += this.stream.next();
        }
      }
      if (state.plain.length) {
        content.push(state.plain);
      }
      return {
        content: content,
        log: this.log
      };
    };

    return DocumentSourceParser;

  })();

  window.DocumentSourceParser = DocumentSourceParser;

  Stream = (function() {
    function Stream(str) {
      this.str = str;
      this.line = 0;
      this.pos = 0;
    }

    Stream.prototype.match = function(pattern, consume) {
      if (consume == null) {
        consume = true;
      }
      if (!pattern.test(this.str)) {
        return false;
      }
      if (consume) {
        this.__move(RegExp.lastMatch);
      }
      return [RegExp.$1, RegExp.$2];
    };

    Stream.prototype.next = function() {
      var ch;
      if (this.empty()) {
        return null;
      } else {
        ch = this.str[0];
        this.__move(ch);
        return ch;
      }
    };

    Stream.prototype.eat = function(p) {
      var ch;
      if (!this.empty() && this.str[0] === p) {
        ch = this.str[0];
        this.__move(ch);
        return ch;
      }
    };

    Stream.prototype.peek = function() {
      if (!this.empty()) {
        return this.str[0];
      } else {
        return null;
      }
    };

    Stream.prototype.empty = function() {
      return this.str.length === 0;
    };

    Stream.prototype.__move = function(str) {
      var lines, ll;
      lines = str.split('\n');
      ll = lines.length - 1;
      if (ll) {
        this.line += ll;
        this.pos = 0;
      }
      this.pos += lines[ll].length;
      return this.str = this.str.substring(str.length);
    };

    return Stream;

  })();

}).call(this);
